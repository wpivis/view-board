/*jshint esversion: 6 */
/*jslint node: true */
/*jshint strict:true */

'use strict';

var fs = require("fs");
var util = require('util');
var path = require('path');
var events = require("events");
var eventEmitter = events.EventEmitter();
var SerialPort = require('serialport');
var tinycolor = require('tinycolor2');

const START_BIT = 128;
const END_BIT = 173;

/**
 * Handles generic errors
 * @param  {Error} 	err  Returning Error
 * @param  {string} type Type of Error
 * @return null
 */
function errorHandler(err, type) {
	if (err) {
		switch(type) {
			case 'W':
			console.log("Error Writing: ", err);
			break;
			default:
			console.log ("Error: ", err);
			break;
		}
	}
}

/**
 * Parses incoming packets
 * @param  {Buffer} data 	Buffer with incoming data
 * @return {Array}      	array of packets
 */
function parsePackets(data) {
	var packetArray = [];
	for (var i=0;i<data.length-1;i++) {
		if (data[i] == 0x13) {
			var packetLength = data[i+1] + 2;
			// console.log("Found a command, " + packetLength + " bits long");

			//Checksum
			var sum = 0;
			// this gonna hurt performance on large data streams..
			// but prob not that significant
			for(var j=i;j<i+packetLength-1;j++) {
				sum += data[j];
			}
			
			//If valid, add to array
			if (sum + data[i+packetLength-1] == 256) {
				// console.log("Valid packet, adding to packet array.");
				var tempBuffer = new Buffer(packetLength-3);
				// Strip header, n-bytes and checksum since we don't need them anymore
				data.copy(tempBuffer, 0, i+2, i+packetLength-1);
				// console.log(tempBuffer);
				packetArray.push(tempBuffer);
			} 
			// else console.log("Invalid/Corrupted packet. Discarding..");
		}
	}

	//Array of packets, eachPl starts with a header and ends with checksum 
	return packetArray;
}

/**
 * Converts Index to XY Coordinate
 * @param  {Number} index 	Index number
 * @return {Object} 		XY Object
 */
function toCoordinate(index) {
	return {x: index%7, y: parseInt(index/7)};
}

/**
 * Converts XY Coordinate to Index
 * @param  {Number} x X-coordinate
 * @param  {Number} y Y-coordinate
 * @return {Number}   Index number
 */
function toIndex(x, y) {
	return (y*7) + x;
}

var Nopixel =  function(configPath) {
	var self = this;
	self.configPath = configPath;
	events.EventEmitter.call(self);

	// Config with default values
	var systemConfiguration = JSON.parse(fs.readFileSync(configPath, "utf-8"));
	var comPort = systemConfiguration[0].comPort || "/dev/ttyACM0";
	var baudRate = systemConfiguration[0].baudRate || 9600;

	var port = new SerialPort(comPort, {baudrate: baudRate});
	console.log("Port opened.");

	port.on("error", (err) => errorHandler(err));
	port.on('data', function (data) {
		var packets = parsePackets(data);
		if (packets.length != 0) {
			packets.forEach(function(el) {
				var eventDetail = {
					x: toCoordinate(el[0]).x,
					y: toCoordinate(el[0]).y,
					index: el[0]
				}
				switch(el[1]) {
					case 0: //Pressed
					self.emit("clicked", eventDetail);
					break;
					case 1: //Hold
					self.emit("pressed", eventDetail);
					break;
					case 2:
					self.emit("released", eventDetail);
					break;
					case 3:
					self.emit("idle", eventDetail);
				}
			})
		} 
		// else {
		// 	console.log("Got something: ");
		// 	console.log(data.toString('ascii'));
		// } 
	});

	/**
	 * Sets a specific pixel
	 * @param {Number} 			x           X-coordinate
	 * @param {Number} 			y           Y-coordinate
	 * @param {String|Object} 	colorString Color string/object - see tinycolor2 inputs
	 * @return {Object} 					Nopixel object
	 */
	self.setPixel = function(x, y, colorString) {
		var colorObj = tinycolor(colorString);
		if (colorObj.isValid()) {
			var colorRGB = colorObj.toRgb();

			port.write(new Buffer.from([START_BIT,104,toIndex(x,y),colorRGB.r,colorRGB.g,colorRGB.b,END_BIT]),
				(err) => errorHandler(err, 'W'));
		} else console.log(colorString + " is not a valid color.");	

		return self;
	}

	/**
	 * Renders the LEDs
	 * @return {Object} Nopixel object
	 */
	self.update = function() {
		port.write(new Buffer.from([START_BIT, 105, END_BIT]), (err) => errorHandler(err, 'W'));

		return self;
	}

	/**
	 * Clears the LEDs
	 * @return {Object} Nopixel object
	 */
	self.clear = function() {
		port.write(new Buffer.from([START_BIT, 106, END_BIT]), (err) => errorHandler(err, 'W'));

		return self;
	}

	/**
	 * Sets the whole board from node-canvas data
	 * @param  {TypedArray} data 	Canvas board data 
	 * @return {Object}      		Nopixel object
	 */
	self.fromCanvas = function(data) {
		//Clean up data by removing the alpha channel
		data = Array.from(data.filter(function(el,i) {return i%4 != 3}));
		data = [START_BIT, 107, 0, 48].concat(data, [173]);

		port.write(new Buffer.from(data), (err) => errorHandler(err, 'W'));

		return self;
	}

	return self;
}


Nopixel.prototype.__proto__ = events.EventEmitter.prototype;
module.exports = Nopixel;